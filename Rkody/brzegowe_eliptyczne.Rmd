---
title: "Zagadnienie brzegowe eliptyczne"
author: "Weronika Lara"
date: "9 września 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Wprowadzenie 

W tej części zajmiemy się zagadnieniem eliptycznym w przestrzeni dwuwymiarowej $\mathbb{R}^2$ postaci
$$
- \Delta u(x) + c u(x) = f(x) \\
u(s) = g(s)
$$

Równanie to wyprowadza postać rekurencyjną

$$
-u_{i-1,j} + 4 u_{ij} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} + ch^2 u_{ij} = h^2 f(x_{ij})
$$

# Implementacja

```{r}

translator= function(i, j, row_size){
  return ( (j-1) * row_size + i)
}

schemat_eliptyczny = function(f, c , g , x0, xn, y0, yn , N)
{
  h1 = (xn-x0) / N
  h2 = (yn-y0) / N
  x = seq(from=x0+h1, to=x0+(N-1)*h1,length.out = N-1)
  y = seq(from=y0+h2, to=y0+(N-1)*h2,length.out = N-1)
  size = (N-1)^2
  A = diag(4+c*h1*h2,nrow=size,ncol=size)
  b_norm = h1*h2*f(x,y)
  b = rep(0, times=(N-1)*(N-1))
  for (i in 1:(N-1)){
    for (j in 1:(N-1)){
      b[translator(i,j,N-1)] = b_norm[i,j]
    }
  }
  for (i in 1:(N-1)){
    for (j in 1:(N-1)){
      # u_{i-1,j}
      if (i == 1) {
        b[translator(i,j, N-1)] = b[translator(i,j, N-1)] + g(x0,y[j])
      } else {
        A[translator(i,j,N-1), translator(i-1,j,N-1)] = -1
      }
      # u_{i+1,j}
      if (i == N-1){
        b[translator(i,j,N-1)] = b[translator(i,j,N-1)] + g(xn,y[j])
      } else {
        A[translator(i,j, N-1), translator(i+1,j, N-1)] = -1
      }
      # u_{i,j-1}
      if (j == 1){
        b[translator(i,j,N-1)] = b[translator(i,j,N-1)] + g(x[i],y0)
      } else {
        A[translator(i,j,N-1), translator(i,j-1,N-1)] = -1
      }
      #u_{i,j+1}
      if (j == N-1){
        b[translator(i,j,N-1)] = b[translator(i,j,N-1)] + g(x[i],yn)
      } else {
        A[translator(i,j,N-1), translator(i,j+1,N-1)] = -1
      }
    }
  }
  u2 = solve(A, b) #definiujemy brzeg
  u = matrix(0, N+1, N+1)
  for (i in 1:(N-1)) {
    for (j in 1:(N-1)){
      u[i+1,j+1] = u2[translator(i,j,N-1)]
    }
  }
  u[1,1] = g(x0,y0);
  for (i in 1:(N-1)){
    u[i+1,1] = g(x[i], y0)
  }
  u[N+1,1] = g(xn,y0);
  for (j in 1:(N-1)) {
    u[N+1,j+1] = g(xn, y[j])
  }
  u[N+1,N+1] = g(xn,yn)
  for (i in 1:(N-1)){
    u[i+1,N+1] = g(x[i],yn)
  }
  u[1,N+1] = g(x0,yn)
  for (j in 1:(N-1)){
    u[1,j+1] = g(x0,y[j])
  }
  result = list(x=c(x0, x, xn), y = c(y0, y, yn), u = u)
  return(result)
}
```

Weźmy równanie róznicowe liniowe drugiego rzędu z warunkami brzegowymi postaci:
$$
\left\lbrace
\begin{array}{c}
-\Delta u(x,y) - \frac{\pi^2}{2}u(x,y) = f(x,y), \quad (x,y) \in \Omega, \\
u(x,y) = g(x,y), \quad (x,y) \in \delta \Omega.\\
\end{array}
\right.
$$
Rozwiązaniem tego równanie będzię funkcja $u$ postaci:
$$
u(x,y) = \sin(\frac{\pi}{2}x) \cdot \sin(\frac{\pi}{2}y)
$$
```{r}
f = function(x,y){
  n = length(x)
  m = length(y)
  return(matrix(0, m, n ))
}
c = -(pi)^2/2
x0 = 0
xn = 1
y0 = 0
yn = 1
N = 50

g = function(x, y)
{
  return( sin(x*pi/2) * sin(y*pi/2))
}

solution = schemat_eliptyczny(f, c , g , x0, xn, y0, yn , N)

```


```{r}
library(plot3D)
x = solution$x
y = solution$y
M = mesh(x,y)
surf3D(M$x,M$y, solution$u )
```

